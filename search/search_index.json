{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to crossclient","text":"<p>Development Version</p> <p>This library is currently in active development and the API is subject to changes. Features, function signatures, and behavior may change between versions without notice.</p> <p><code>crossclient</code> is Python client for the SWEET-CROSS API. It implements method to enable convenient interaction with the API including result submission without the need to upload files through the webpage and analyzing data without manual downloads. Common use cases are:</p> <ul> <li>Result Submission</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>crossclient</code> directly from GitHub.</p>"},{"location":"#with-pip","title":"With <code>pip</code>","text":"<pre><code>pip install git+https://github.com/sweet-cross/crossclient.git\n</code></pre>"},{"location":"#with-uv","title":"With <code>uv</code>","text":"<pre><code>uv pip install git+https://github.com/sweet-cross/crossclient.git\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>Development Version</p> <p>This library is currently in active development and the API is subject to changes. Features, function signatures, and behavior may change between versions without notice.</p>"},{"location":"api/#cross-client","title":"Cross Client","text":"<p>The <code>CrossClient</code> is main client to interact with CROSS API it provides different methods that formulate the request to the API and return the response. It is initialized using the user name and password and automatically handles authentication.</p> <p>The standard usage is:</p> Example: Initializing the CrossClient<pre><code>from crossclient import CrossClient\n\nclient = CrossClient(\n    username=\"me\",\n    password=\"my_password\",\n)\n</code></pre>"},{"location":"api/#crossclient.cross_client.CrossClient","title":"<code>crossclient.cross_client.CrossClient</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>CrossClient is the basic client to interact with the SweetCross API. It provides basic request methods to interact with the API endpoints. It also handles authentication via tokens based on the underlying TokenClient.</p> Source code in <code>crossclient/cross_client.py</code> <pre><code>class CrossClient(BaseModel):\n    \"\"\"CrossClient is the basic client to interact with the SweetCross API. It\n    provides basic request methods to interact with the API endpoints. It also\n    handles authentication via tokens based on the underlying TokenClient.\"\"\"\n\n    username: str = Field(description=\"The username for authentication.\")\n    password: str = Field(description=\"The password for authentication.\")\n    base_url: str = Field(\n        default=\"https://sweetcross.link/api/v1\",\n        description=\"The base URL of the SweetCross API.\",\n    )\n    transport: Any | None = Field(\n        default=None,\n        exclude=True,\n        description=\"Optional custom transport for the HTTP client.\",\n    )\n    _client: httpx.Client | None = None\n    _token_client: TokenClient | None = None\n\n    @model_validator(mode=\"after\")\n    def _initialized_clients(self) -&gt; \"CrossClient\":\n        \"\"\"Validator to retrieve the token after model initialization and\n        initialize the HTTP client.\"\"\"\n        self._token_client = TokenClient(\n            username=self.username,\n            password=self.password,\n            base_url=self.base_url,\n            transport=self.transport,\n        )\n        self._client = httpx.Client(base_url=self.base_url, transport=self.transport)\n        return self\n\n    def _request(\n        self, method: str, endpoint: str, headers: dict | None = None, **kwargs\n    ) -&gt; httpx.Response:\n        \"\"\"Formulate an API requests given the name of the endpoint and the\n        request method\n\n        Args:\n            method (str): The HTTP method to use (e.g., \"GET\", \"POST\").\n            endpoint (str): The API endpoint to send the request to.\n            headers (dict | None): Headers to include in the request.\n            **kwargs: Additional arguments to pass to the request method.\n\n        Returns:\n            httpx.Response: The response from the API.\n        \"\"\"\n        assert self._token_client is not None, \"TokenClient should be initialized\"\n        assert self._client is not None, \"Client should be initialized\"\n        if headers is None:\n            headers = {}\n        headers[\"Authorization\"] = (\n            f\"{self._token_client.token.token_type} {self._token_client.token.access_token}\"\n        )\n        response = self._client.request(method, endpoint, headers=headers, **kwargs)\n        return response\n\n    def post(\n        self, endpoint: str, json: dict | None = None, **kwargs: dict\n    ) -&gt; httpx.Response:\n        \"\"\"Send a POST request to the specified endpoint.\n\n        Args:\n            endpoint (str): The API endpoint to send the request to.\n            json (dict | None): The JSON payload to include in the request body.\n            **kwargs: Additional arguments to pass to the request method.\n        Returns:\n            httpx.Response: The response from the API.\n        \"\"\"\n        # take care of file handles if any\n        file_handles_to_close = []\n        if \"files\" in kwargs:\n            for _, file_tuple in kwargs[\"files\"].items():\n                # file_tuple is (filename, file_handle, mimetype)\n                file_handle = file_tuple[1]\n                if hasattr(file_handle, \"close\"):\n                    file_handles_to_close.append(file_handle)\n        try:\n            # Pass control to the request method for authentication and execution\n            return self._request(\"POST\", endpoint, json=json, **kwargs)\n        finally:\n            # in any case, close the file handles after request completion\n            for handle in file_handles_to_close:\n                handle.close()\n\n    def get(self, endpoint: str, **kwargs: dict) -&gt; httpx.Response:\n        \"\"\"Send a GET request to the specified endpoint.\n\n        Args:\n            endpoint (str): The API endpoint to send the request to.\n            **kwargs: Additional arguments to pass to the request method.\n\n        Returns:\n            httpx.Response: The response from the API.\n        \"\"\"\n        return self._request(\"GET\", endpoint, **kwargs)\n</code></pre>"},{"location":"api/#crossclient.cross_client.CrossClient.get","title":"<code>get(endpoint, **kwargs)</code>","text":"<p>Send a GET request to the specified endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The API endpoint to send the request to.</p> required <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to the request method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>httpx.Response: The response from the API.</p> Source code in <code>crossclient/cross_client.py</code> <pre><code>def get(self, endpoint: str, **kwargs: dict) -&gt; httpx.Response:\n    \"\"\"Send a GET request to the specified endpoint.\n\n    Args:\n        endpoint (str): The API endpoint to send the request to.\n        **kwargs: Additional arguments to pass to the request method.\n\n    Returns:\n        httpx.Response: The response from the API.\n    \"\"\"\n    return self._request(\"GET\", endpoint, **kwargs)\n</code></pre>"},{"location":"api/#crossclient.cross_client.CrossClient.post","title":"<code>post(endpoint, json=None, **kwargs)</code>","text":"<p>Send a POST request to the specified endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The API endpoint to send the request to.</p> required <code>json</code> <code>dict | None</code> <p>The JSON payload to include in the request body.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments to pass to the request method.</p> <code>{}</code> <p>Returns:     httpx.Response: The response from the API.</p> Source code in <code>crossclient/cross_client.py</code> <pre><code>def post(\n    self, endpoint: str, json: dict | None = None, **kwargs: dict\n) -&gt; httpx.Response:\n    \"\"\"Send a POST request to the specified endpoint.\n\n    Args:\n        endpoint (str): The API endpoint to send the request to.\n        json (dict | None): The JSON payload to include in the request body.\n        **kwargs: Additional arguments to pass to the request method.\n    Returns:\n        httpx.Response: The response from the API.\n    \"\"\"\n    # take care of file handles if any\n    file_handles_to_close = []\n    if \"files\" in kwargs:\n        for _, file_tuple in kwargs[\"files\"].items():\n            # file_tuple is (filename, file_handle, mimetype)\n            file_handle = file_tuple[1]\n            if hasattr(file_handle, \"close\"):\n                file_handles_to_close.append(file_handle)\n    try:\n        # Pass control to the request method for authentication and execution\n        return self._request(\"POST\", endpoint, json=json, **kwargs)\n    finally:\n        # in any case, close the file handles after request completion\n        for handle in file_handles_to_close:\n            handle.close()\n</code></pre>"},{"location":"api/#result-submission","title":"Result Submission","text":"<p><code>crossclient</code> allows to automatically submit your result files to the CROSS platform. After obtaining the user name and password, result submission requires initializing the <code>CrossClient</code>. Equipped with the client, the <code>submit_results</code> function allows submitting the results either from a locally stored csv or Excel file or from a pandas DataFrame. The function takes a <code>submission_contract</code> argument that determines under which project (identified by the contract) the file is submitted. The standard is <code>\"submission_cross2025\"</code>.</p> <p>The standard way of uploading a file is:</p> Example: Submitting a CSV file<pre><code>from crossclient import CrossClient, submit_results\n\nclient = CrossClient(\n    username=\"me\",\n    password=\"my_password\",\n)\n\nfn_csv = \"path_to_my.csv\"\nsubmit_results(\n    client=client,\n    fn_results=fn_csv\n)\n</code></pre> <p>Submission with a pandas DataFrame requires that the file name has a \".csv\" extension. In the back, the function converts the DataFrame to a csv file and uses the given name to upload the file. Note that indexes are ignored, i.e., only the columns of the DataFrame are used to create the csv file.</p> Example: Submitting results from a DataFrame<pre><code>import pandas as pd\nfrom crossclient import CrossClient, submit_results\n\nclient = CrossClient(\n    username=\"me\",\n    password=\"my_password\",\n)\n\nfn_csv = \"my_upload_name.csv\"\ndf = pd.DataFrame({\"a\": [1, 2], \"b\": [3, 4]})\nsubmit_results(\n    client=client,\n    fn_results=fn_csv,\n    df_results=df,\n    submission_contract=\"submission_cross2025\"\n)\n</code></pre> <p>Submits the results using the provided CrossClient instance. The results are expected to be provided as pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>CrossClient</code> <p>An instance of CrossClient to handle submission.</p> required <code>fn_results</code> <code>str | Path</code> <p>The file path to the results to be submitted.</p> required <code>df_results</code> <code>DataFrame | None</code> <p>The results as a pandas DataFrame. If None, the results will be read from the file specified by fn_results. If provided, the filename must end with .csv, i.e., data are uploaded as csv. Note: Indexes of the DataFrame are not included in the uploaded file.</p> <code>None</code> <code>submission_contract</code> <code>str | None</code> <p>The submission contract identifier. If None the default contract will be used: submission_cross2025</p> <code>None</code> <p>Raises:     ValueError: If the file format is unsupported.     ValueError: If the submission fails.</p> Source code in <code>crossclient/result_submission.py</code> <pre><code>def submit_results(\n    client: CrossClient,\n    fn_results: str | Path,\n    df_results: pd.DataFrame | None = None,\n    submission_contract: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Submits the results using the provided CrossClient instance. The results\n    are expected to be provided as pandas DataFrame.\n\n    Args:\n        client (CrossClient): An instance of CrossClient to handle submission.\n        fn_results (str | Path): The file path to the results to be submitted.\n        df_results (pd.DataFrame | None): The results as a pandas DataFrame.\n            If None, the results will be read from the file specified by fn_results.\n            If provided, the filename must end with .csv, i.e., data are uploaded\n            as csv.\n            Note: Indexes of the DataFrame are not included in the uploaded file.\n        submission_contract (str | None): The submission contract identifier.\n            If None the default contract will be used: submission_cross2025\n    Raises:\n        ValueError: If the file format is unsupported.\n        ValueError: If the submission fails.\n    \"\"\"\n    # preprocessing\n    if submission_contract is None:\n        submission_contract = \"submission_cross2025\"\n    fn_results = Path(fn_results)\n\n    # check correct file format\n    if fn_results.suffix not in {\".csv\", \".xlsx\", \".xls\"}:\n        raise ValueError(\n            \"Unsupported file format. Please provide a CSV or Excel file. File name must end with .csv, .xlsx or .xls\"\n        )\n\n    # create file description\n    file_description = {\n        \"description\": (\n            f\"Submission of results file {fn_results.name} at \"\n            f\"{datetime.datetime.now(datetime.timezone.utc)} through crossclient.\"\n        ),\n        \"uploaded_by\": client.username,\n    }\n\n    # create the file payload and submit the data\n    file_payload: dict[str, tuple[str, IO[bytes], str]] = {}\n    if df_results is None:  # read from file if no dataframe is provided\n        if not fn_results.exists():  # check that file exists\n            raise ValueError(f\"The specified results file does not exist: {fn_results}\")\n        with open(fn_results, \"rb\") as f:\n            file_payload[\"file\"] = (\n                fn_results.name,\n                f,\n                \"application/octet-stream\",  # Generic binary MIME type\n            )\n            # submit file\n            res = client.post(\n                endpoint=f\"/result/upload/{submission_contract}\",\n                files=file_payload,\n                data={\"file_description\": json.dumps(file_description)},\n            )\n    else:  # create file from dataframe\n        if fn_results.suffix != \".csv\":\n            raise ValueError(\n                \"When providing results as a DataFrame, the filename must end with .csv\"\n            )\n        buffer: IO[bytes] = BytesIO()\n        df_results.to_csv(buffer, index=False, encoding=\"utf-8\")\n        buffer.seek(0)\n        file_payload[\"file\"] = (\n            fn_results.name,\n            buffer,\n            \"application/octet-stream\",\n        )\n        # submit file\n        res = client.post(\n            endpoint=f\"/result/upload/{submission_contract}\",\n            files=file_payload,\n            data={\"file_description\": json.dumps(file_description)},\n        )\n\n    # todo: handle response\n    if res.status_code == 201:\n        print(\"Submission successful.\")\n    else:\n        # todo: improve error handling\n        raise ValueError(\n            f\"Submission failed with status code {res.status_code}: {res.text}\"\n        )\n</code></pre>"},{"location":"api/#crossclient.result_submission.submit_results","title":"<code>submit_results(client, fn_results, df_results=None, submission_contract=None)</code>","text":"<p>Submits the results using the provided CrossClient instance. The results are expected to be provided as pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>CrossClient</code> <p>An instance of CrossClient to handle submission.</p> required <code>fn_results</code> <code>str | Path</code> <p>The file path to the results to be submitted.</p> required <code>df_results</code> <code>DataFrame | None</code> <p>The results as a pandas DataFrame. If None, the results will be read from the file specified by fn_results. If provided, the filename must end with .csv, i.e., data are uploaded as csv. Note: Indexes of the DataFrame are not included in the uploaded file.</p> <code>None</code> <code>submission_contract</code> <code>str | None</code> <p>The submission contract identifier. If None the default contract will be used: submission_cross2025</p> <code>None</code> <p>Raises:     ValueError: If the file format is unsupported.     ValueError: If the submission fails.</p> Source code in <code>crossclient/result_submission.py</code> <pre><code>def submit_results(\n    client: CrossClient,\n    fn_results: str | Path,\n    df_results: pd.DataFrame | None = None,\n    submission_contract: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Submits the results using the provided CrossClient instance. The results\n    are expected to be provided as pandas DataFrame.\n\n    Args:\n        client (CrossClient): An instance of CrossClient to handle submission.\n        fn_results (str | Path): The file path to the results to be submitted.\n        df_results (pd.DataFrame | None): The results as a pandas DataFrame.\n            If None, the results will be read from the file specified by fn_results.\n            If provided, the filename must end with .csv, i.e., data are uploaded\n            as csv.\n            Note: Indexes of the DataFrame are not included in the uploaded file.\n        submission_contract (str | None): The submission contract identifier.\n            If None the default contract will be used: submission_cross2025\n    Raises:\n        ValueError: If the file format is unsupported.\n        ValueError: If the submission fails.\n    \"\"\"\n    # preprocessing\n    if submission_contract is None:\n        submission_contract = \"submission_cross2025\"\n    fn_results = Path(fn_results)\n\n    # check correct file format\n    if fn_results.suffix not in {\".csv\", \".xlsx\", \".xls\"}:\n        raise ValueError(\n            \"Unsupported file format. Please provide a CSV or Excel file. File name must end with .csv, .xlsx or .xls\"\n        )\n\n    # create file description\n    file_description = {\n        \"description\": (\n            f\"Submission of results file {fn_results.name} at \"\n            f\"{datetime.datetime.now(datetime.timezone.utc)} through crossclient.\"\n        ),\n        \"uploaded_by\": client.username,\n    }\n\n    # create the file payload and submit the data\n    file_payload: dict[str, tuple[str, IO[bytes], str]] = {}\n    if df_results is None:  # read from file if no dataframe is provided\n        if not fn_results.exists():  # check that file exists\n            raise ValueError(f\"The specified results file does not exist: {fn_results}\")\n        with open(fn_results, \"rb\") as f:\n            file_payload[\"file\"] = (\n                fn_results.name,\n                f,\n                \"application/octet-stream\",  # Generic binary MIME type\n            )\n            # submit file\n            res = client.post(\n                endpoint=f\"/result/upload/{submission_contract}\",\n                files=file_payload,\n                data={\"file_description\": json.dumps(file_description)},\n            )\n    else:  # create file from dataframe\n        if fn_results.suffix != \".csv\":\n            raise ValueError(\n                \"When providing results as a DataFrame, the filename must end with .csv\"\n            )\n        buffer: IO[bytes] = BytesIO()\n        df_results.to_csv(buffer, index=False, encoding=\"utf-8\")\n        buffer.seek(0)\n        file_payload[\"file\"] = (\n            fn_results.name,\n            buffer,\n            \"application/octet-stream\",\n        )\n        # submit file\n        res = client.post(\n            endpoint=f\"/result/upload/{submission_contract}\",\n            files=file_payload,\n            data={\"file_description\": json.dumps(file_description)},\n        )\n\n    # todo: handle response\n    if res.status_code == 201:\n        print(\"Submission successful.\")\n    else:\n        # todo: improve error handling\n        raise ValueError(\n            f\"Submission failed with status code {res.status_code}: {res.text}\"\n        )\n</code></pre>"},{"location":"api/#token-client","title":"Token Client","text":"<p>The <code>TokenClient</code> handles authentication and token refreshing. In normal use cases this client is not directly used but automatically handled through the CrossClient.</p>"},{"location":"api/#crossclient.token_client.TokenClient","title":"<code>crossclient.token_client.TokenClient</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The TokenClient handles authentication and token management for the API. It retrieves and refreshes access tokens as needed. For most use cases, a direct interaction with this client is not necessary, as the CrossClient will manage tokens automatically by incorporating the TokenClient internally.</p> Source code in <code>crossclient/token_client.py</code> <pre><code>class TokenClient(BaseModel):\n    \"\"\"The TokenClient handles authentication and token management for the API. It\n    retrieves and refreshes access tokens as needed. For most use cases, a direct\n    interaction with this client is not necessary, as the CrossClient will manage\n    tokens automatically by incorporating the TokenClient internally.\"\"\"\n\n    username: str = Field(description=\"The username for authentication.\")\n    password: str = Field(description=\"The password for authentication.\")\n    base_url: str = Field(description=\"The base URL of the API.\")\n    transport: Any | None = Field(\n        default=None,\n        exclude=True,\n        description=\"Optional custom transport for the HTTP client.\",\n    )\n    _token: Token | None = PrivateAttr(default=None)\n    _client: httpx.Client | None = PrivateAttr(default=None)\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def url_auth(self) -&gt; str:\n        \"\"\"URL of the authentication endpoint.\"\"\"\n        return f\"{self.base_url}/login/access_token\"  # pragma: no cover\n\n    @computed_field  # type: ignore[prop-decorator]\n    @property\n    def url_refresh(self) -&gt; str:\n        \"\"\"URL of the token refresh endpoint.\"\"\"\n        return f\"{self.base_url}/login/refresh_token\"  # pragma: no cover\n\n    @model_validator(mode=\"after\")\n    def _initialize_client_and_token(self) -&gt; \"TokenClient\":\n        self._client = httpx.Client(base_url=self.base_url, transport=self.transport)\n        self._token = self._get_token()\n        return self\n\n    @property\n    def token(self) -&gt; Token:\n        \"\"\"Get the current token.\n\n        Returns:\n            Token: The current authentication token.\n        \"\"\"\n        if self._token is None or self._token.is_expired:\n            # Todo we could use refresh token here\n            self._token = self._get_token()\n        return self._token\n\n    def _get_token(self) -&gt; Token:\n        \"\"\"Retrieve a new access token using the refresh token.\n\n        Returns:\n            str: The new access token.\n        \"\"\"\n        assert self._client is not None, \"Client should be initialized\"\n        response = self._client.post(\n            self.url_auth,\n            data={\"username\": self.username, \"password\": self.password},\n        )\n        if response.status_code != 200:\n            raise ValueError(f\"Failed to obtain access token: {response.text}\")\n        return Token.model_validate(response.json())\n</code></pre>"},{"location":"api/#crossclient.token_client.TokenClient.token","title":"<code>token</code>  <code>property</code>","text":"<p>Get the current token.</p> <p>Returns:</p> Name Type Description <code>Token</code> <code>Token</code> <p>The current authentication token.</p>"},{"location":"api/#crossclient.token_client.TokenClient.url_auth","title":"<code>url_auth</code>  <code>property</code>","text":"<p>URL of the authentication endpoint.</p>"},{"location":"api/#crossclient.token_client.TokenClient.url_refresh","title":"<code>url_refresh</code>  <code>property</code>","text":"<p>URL of the token refresh endpoint.</p>"},{"location":"api/#crossclient.token_client.Token","title":"<code>crossclient.token_client.Token</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Token represents the authentication token structure returned by the API. It includes the access token, refresh token, token type, creation timestamp, and expiration details.</p> Source code in <code>crossclient/token_client.py</code> <pre><code>class Token(BaseModel):\n    \"\"\"Token represents the authentication token structure returned by the API. It\n    includes the access token, refresh token, token type, creation timestamp, and\n    expiration details.\"\"\"\n\n    access_token: str = Field(description=\"The access token for authentication.\")\n    refresh_token: str = Field(\n        description=\"The refresh token for obtaining new access tokens.\"\n    )\n    token_type: str = Field(description=\"The type of the token.\")\n    created_at: datetime = Field(\n        default=datetime.now(timezone.utc),\n        description=\"The timestamp when the token was created.\",\n    )\n    expires_in: int = Field(\n        description=\"The duration in seconds until the access token expires.\"\n    )\n    refresh_expires_in: int = Field(\n        description=\"The duration in seconds until the refresh token expires.\"\n    )\n\n    @property\n    def is_expired(self) -&gt; bool:\n        \"\"\"Check if the access token has expired.\n\n        Returns:\n            bool: True if the token has expired, False otherwise.\n        \"\"\"\n        expiration_time = self.created_at + timedelta(seconds=self.expires_in)\n        return datetime.now(timezone.utc) &gt;= expiration_time\n\n    @property\n    def is_refresh_expired(self) -&gt; bool:\n        \"\"\"Check if the refresh token has expired.\n\n        Returns:\n            bool: True if the refresh token has expired, False otherwise.\n        \"\"\"\n        refresh_expiration_time = self.created_at + timedelta(\n            seconds=self.refresh_expires_in\n        )\n        return datetime.now(timezone.utc) &gt;= refresh_expiration_time\n</code></pre>"},{"location":"api/#crossclient.token_client.Token.is_expired","title":"<code>is_expired</code>  <code>property</code>","text":"<p>Check if the access token has expired.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the token has expired, False otherwise.</p>"},{"location":"api/#crossclient.token_client.Token.is_refresh_expired","title":"<code>is_refresh_expired</code>  <code>property</code>","text":"<p>Check if the refresh token has expired.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the refresh token has expired, False otherwise.</p>"}]}